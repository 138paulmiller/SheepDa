#!/usr/bin/env python

'''
SheepDa - A "Soft" Functional Scripting Language

Copyright 2017 Paul Miller (github.com/138paulmiller)

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

'''
import sys, os
VERSION = 0.1
DEBUG = True
HELP = open(os.path.dirname(os.path.abspath(__file__))+"/HELP").read()
SYNTAX = open(os.path.dirname(os.path.abspath(__file__))+"/SYNTAX").read()
'''
AST Node Tags
'''
APPLY 	= 'APPLY' 	# Lambda Application
CLOSURE = 'CLOSURE'  # Lambda Abstaction
ASSIGN 	= 'ASSIGN'  # Variable assignement
BUILTIN = 'BUILTIN' # Builtin Variables

'''
Token Symbol Tags
'''
LPAREN 	= 'LPAREN'
RPAREN 	= 'RPAREN'
LAMBDA 	= 'LAMBDA'
DOT 	= 'DOT'
STRING	= 'STRING'
EQUAL	= 'EQUAL'
ID 		= 'ID'
FLOAT 	= 'FLOAT'
INT 	= 'INT'
COMMENT = 'COMMENT'
EOI 	= 'EOI'
ERROR 	= 'ERROR'
KEYWORD	= 'KEYWORD' 

keywords = ['*','/','+', '<', '>', 'eq', 'and','or','not', 'print', 'read', 'true', 'false']
controls = ['if']

#------------------------Repl--------------------------#
def main(args):
	bindings = {} 
	if len(args) > 0: 
		if args[0] == '-h':
			print HELP
		if args[0] == '-s':
			print SYNTAX
		else:
			interpret(file(args[0]).read(), bindings)
	else: # repl
		source = raw_input('\nSheepDa Version '+str(VERSION)+'\nIf you are new, type help\n\n@>')			
		while source != 'quit':
			if source == 'help':
				print HELP
			elif source == 'unbind':
				# delete all user defined bindings
				bindings.clear() 
			else:
				exprs = interpret(source, bindings)
				for expr in exprs:
					if isinstance(expr, tuple) and expr[0] == ERROR:					
						print ERROR + ' ' + expr[1]
			source = raw_input('@>')			
		print 'Goodbye' 

def interpret(source, bindings):
	lexer = Lexer(source)
	# generate ast [expr ... ]
	ast = parse(lexer)
	exprs = []
	# evaluate each expr in ast
	for node in ast:
		expr = evaluate(node, bindings)			
		#print expr	
		exprs.append(expr)
	return exprs

#------------------------Lexer --------------------------#	
class Lexer:
	'''
	 Returns tokens (tag, value)
	'''
	def __init__(self, input):
		self.input = input
		self.pos = 0 
		self.len = len(self.input)

	def peek(self):
		token = None
		# eat whitespace
		while self.pos < self.len and  \
		  (self.input[self.pos] == ' '  or \
		  self.input[self.pos] == '\t' or \
		  self.input[self.pos] == '\n'):
			self.pos+=1
		if self.pos >= self.len:
			token = (EOI, 'End of Input')
		else:
			sym = self.input[self.pos]
			if  sym == '(':
				token = (LPAREN,sym )
			elif sym == ')':
				token = (RPAREN, sym)
			elif sym == '\\':
				token = (LAMBDA, sym)
			elif sym == '.': 
				token = (DOT, sym)
			elif sym == '=': 
				token = (EQUAL, sym)
			elif sym  in keywords:
				token = (KEYWORD, sym)
			elif sym == '\"': 
				string = ""
				i = self.pos+1
				while i < self.len and self.input[i] != '\"':
					string += self.input[i]
					i += 1
				if i < self.len:
					i+=1
					token = (STRING, string)
				else:
					token = (ERROR, 'Missing closing quote')
			elif sym == ';':
				comment = ''
				while self.pos < self.len and self.input[self.pos] != '\n':
					comment += self.input[self.pos]
					self.pos += 1
				token = (COMMENT, comment) 
			elif sym.isalpha(): # id
				def_id = sym
				i = self.pos+1
				while i <  self.len and self.input[i].isalnum(): 
					def_id += self.input[i]
					i+=1
				if def_id in keywords or def_id in controls:
					token = (KEYWORD, def_id)				
				else:
					token = (ID, def_id)
				
			elif sym.isdigit() or sym == '-':
				# negative number
				if sym.isdigit() or (sym == '-' and self.pos+1 < self.len and self.input[self.pos+1].isdigit()):
					num = sym
					i = self.pos+1
					while i <  self.len and self.input[i].isalnum(): 
						num += self.input[i]
						i+=1
					if i < len(self.input) and self.input[i] == '.':
						num += self.input[i]
						i+=1					
						while i < self.len and \
							self.input[i].isalnum(): 
							num += self.input[i]
							i+=1
						token = (FLOAT, num)
					else:
						token = (INT, num)
				else: # subtraction operator 	
					token = (KEYWORD, sym)
			else:
				token = (ERROR, 'Unknown Token: ' + self.input[self.pos])
		return token									

	def next(self):
		token = self.peek()
		if token:
			if token[0] != ERROR:
				# offset input by token lexeme len
				self.pos += len(token[1])
				if token[0] == STRING: #offset for both quotes read but not captured
					self.pos += 2
		else:
			token = (ERROR, ' Unexpected NULL Token') 
		return token
#------------------------Parser --------------------------#
def parse(lexer):
	'''
	Returns AST Nodes 
		(ASSIGN, (def_id_id, expr))
		(CLOSURE, ([<def_id_id> ...], expr))
		(APPLY [ID KEYWORD] [<expr> ...])
	'''
	ast = []
	tag, value = lexer.peek()
	while tag != ERROR and tag != EOI:
		if tag == ID:
			# get def id 
			def_id = lexer.next()
			# check next token for equal sign
			tag, value = lexer.next()
			if tag == EQUAL:
				# return def_id value (id) and expression
				ast.append((ASSIGN, (def_id[1], parse_expr(lexer))))
			else: # standalone def_id
				ast.append(def_id)
		elif tag != COMMENT: # ignore comments
			ast.append(parse_expr(lexer))
		tag, value = lexer.peek()

	return ast

def parse_expr(lexer):
	'''
	Parses individual expressions
	'''
	tag, value = lexer.next()
	root = None
	if tag in [KEYWORD, ID, FLOAT, INT, STRING]: # if ID or Float or ...
		 # eat token
		root = (tag, value)
		# return 
	elif tag == LAMBDA: # if abstraction
		bindings = [] #  bound parameter ids
		# get next, must be either def_id or dot
		tag, value = lexer.next()
		# get all following def_id values (ids)
		while tag == ID:
			bindings.append(value)
			tag, value = lexer.next()
		if tag == DOT:
			root = (CLOSURE, (bindings, parse_expr(lexer)))
		else:
			root = (ERROR, 'Expected ' + DOT + ' at: ' + value)
	elif tag == LPAREN: # if application
		# apply first expression to all expressions until rparen
		expr = None 
		def_id = parse_expr(lexer)
		if def_id[0] != ID and def_id[0] != KEYWORD:
		 	expr = def_id
		else:
		 	expr = def_id[1]
		args = []
		# eat lparen
		tag, value = lexer.peek()
		while tag != RPAREN and tag != ERROR and tag != EOI:	
			args.append(parse_expr(lexer))
			tag, value = lexer.peek()
		if tag == ERROR or tag == EOI:
			root = ERROR, "Missing Closing Parentheses!" 		
		else:
			#eat rparen
			lexer.next()
			root = (APPLY, (expr, args))
	elif tag == COMMENT or tag == ERROR:
		root = tag, value
	else:
		root = (ERROR, 'Unexpected :'+ value)
	return root

#------------------------Closure --------------------------#
class Closure:
	'''
		Closure Container
	'''
	def __init__(self, bindings, params, expr):
		# locally bound def_idiables
		self.bindings = {}
		for def_id in bindings.keys():
			self.bindings[def_id] = bindings[def_id]

		# parameters to be substituted at call binding scope
		self.params = []
		for def_id in params:
			self.params.append(def_id)		
		# expression to evaluate at the scope of bindings
		self.expr = expr

	def __repr__(self):
		s = '('
		for p in self.params:
			s+= p + ' '
		s += ')'
			
		# s += ')\n\tBINDINGS: '
		# for def_id, value in self.bindings.items():
		# 	s += '\n\t\t' + def_id + ': ' + str(value) 
		return  s
	
#------------------------Evaluate Builtins--------------------------#
def eval_add(bindings):
	left = bindings['_x']
	right = bindings['_y']
	try:			
		if isinstance(left, str):
			right = str(right)
		elif isinstance(right, str):
			left = str(left)
		expr = left + right
	except:
		expr = (ERROR, "Invalid Operands: Expected (+ <Int|Float|String> <Int|Float|String>)")						 			
	return expr

def eval_sub(bindings):
	left = bindings['_x']
	right = bindings['_y']
	try:	
		# if either operands are strings, get the intersection of the two
		if isinstance(left, str) or isinstance(right, str):
			if right == None:
				expr = left
			else:
				expr = str(left).replace( str(right), '')	
		else:
			expr = left - right 		
	except:
		expr = (ERROR, "Invalid Operands:Expected (- <Int|Float|String> <Int|Float|String>)")						 			
	return expr

def eval_mul(bindings):
	left = bindings['_x']
	right = bindings['_y']
	try:			
		if isinstance(left, str):	
			expr = ""
		# expect integer value (number of times to repeat!
			if isinstance(right, int):
			 	while right > 0:
					expr += left
					right -= 1
			elif isinstance(right, str):	
				#return merged string
				r = len(right)
				for i in range(0,len(left)):
					expr += left[i]
					if i < r:
						expr += right[i]
		else:
			expr = left * right
	except:			
		expr = (ERROR, "Invalid Operands: Expected  (* <Int|Float|String> <Int|Float|String>)")
	return expr						

def eval_div(bindings):
	left = bindings['_x']
	right = bindings['_y']
	try:
		if isinstance(left, str):	
		# get the intersection!
			if right == None:
				expr = left
			else:
				right = str(right)
				expr = ""
			 	for sym in left:
					if not sym in right:
					  expr += sym
		else:
			expr = left / right	
	except:
		expr = (ERROR, "Invalid Operands: Expected  (/ <Int|Float|String> <Int|Float|String>)")
	return expr							

def eval_not(bindings):
	if not bindings['_x']:
		return  'true'
	else:
		return  'false'	

def eval_lt(bindings):
	if bindings['_x'] < bindings['_y']:
		return  'true'
	else:
		return  'false'

def eval_gt(bindings):
	if bindings['_x'] > bindings['_y']:
		return  'true'
	else:
		return  'false'

def eval_eq(bindings):
	if bindings['_x'] is bindings['_y']:
		return  'true'
	else:
		return  'false'
	
def eval_and(bindings):
	if bindings['_x'] and bindings['_y']:
		return  'true'
	else:
		return  'false'

def eval_or(bindings):
	left = bindings['_x']
	# lazy eval
	if left:			
		expr = left or bindings['_y']
	else:
		expr = left
	if expr:
		expr = 'true'
	else:
		expr = 'false'
	return expr

def eval_print(bindings):
	expr = bindings['_x']
	print expr
	return expr

def eval_print(bindings):
	expr = bindings['_x']
	if expr == True:
		expr = 'true'
	elif expr == False:
		expr = 'false'	
	print expr
	return expr


def eval_if(bindings):
	cond = evaluate(bindings['_x'], bindings)	
	if cond != 'false' and (cond is 'true' or cond != 0) :
		# if error
		if isinstance(cond, tuple) and cond[0] is ERROR:
			expr = cond	
		else:
			# evaluate true expr
			expr = evaluate(bindings['_y'], bindings)	
	else:
		# evaluate false expr
		expr = evaluate(bindings['_z'], bindings)	
	return expr
'''
	Builtin Evaluate Action Table	
	symbol : (function(bindings), paramcount)
'''
builtins = {
	'if'	:(eval_if, 3),
	'+'		:(eval_add, 2),
	'-'		:(eval_sub,2),
	'*'		:(eval_mul, 2),
	'/'		:(eval_div, 2),
	'<'		:(eval_lt, 2),
	'>'		:(eval_gt,2),
	'eq'	:(eval_eq,2),
	'and'	:(eval_and,2),
	'or'	:(eval_or,2),
	'not'	:(eval_not,1),
	'print'	:(eval_print,1 )
}
def eval_builtin(root, bindings):
	expr = None
	#if def_id then requesting closure definition
	if root[0] == KEYWORD:
		tag, value = root
		closure_tag = (BUILTIN, value)
		if value == 'true':
			expr = True
		elif value ==  'false':
			expr = False	
		elif value in builtins:
			arg_count = builtins[value][1]
			if arg_count == 1:
				expr = bindings[value] = Closure(bindings,  ['_x'], closure_tag)
			elif arg_count == 2:
				expr = bindings[value] = Closure(bindings,  ['_x', '_y'], closure_tag)
			elif arg_count == 3:
				expr = bindings[value] = Closure(bindings,  ['_x', '_y', '_z'], closure_tag)
	# else ( def_id, args) call to built_in closure
	elif root[0] == ERROR:
		expr = root
	else: 
		expr= builtins[root][0](bindings)	
	return expr

#------------------------Evaluate --------------------------#
def evaluate(root, bindings):
	expr = root # evaluated expression
	tag, value = root
	if tag == ASSIGN:
		# add expr to binding with def_id key
		if bindings.get(value[0]):
			print value[0], "Already exists!"	
			expr = None	
		else:
			expr = evaluate(value[1], bindings)
			if not isinstance(expr, tuple) or not expr[0] == ERROR:
				bindings[value[0]] = expr # is not error, bind
	elif tag == CLOSURE:
		# return a closure object with parent bindings
		expr =  Closure(bindings, value[0], value[1])
	elif tag == APPLY:
		# Evaluate by  binding all closure params with each args
		def_id = value[0] # get closure id
		args = value[1]   
		closure = None
		# if an application, get the closure definition
		if def_id[0] == APPLY:
			closure = evaluate(def_id, bindings)
		# if not an application, and not user defined, request builtin closure def
		elif def_id not in bindings:
			# get builtin closure 
			closure = evaluate((KEYWORD, def_id), bindings)
		# get the closure to be called
		else:
			closure = bindings[def_id]
		# if closure was found 
		if isinstance(closure, Closure):
			count= len(args)
			params = None
			params = closure.params
			if len(params) != count:
				expr = (ERROR, 'Incorrect argument amount passed to application: '+ str(def_id))
			elif def_id in controls:
				# if a control structure, add arguments to bindings				
				for i in range(0, count):
					# do not evaluate args in control structure
					bindings[params[i]] = args[i] 	
				expr = eval_builtin(def_id,  bindings)
			else:
				# if a application closure
				local_bindings	= {}
				# bind all arguments to closures local bindings
				for bind in bindings:
					local_bindings[bind] = bindings[bind]
				# update closure bindings last, will add closure precedence over calling
				for bind in closure.bindings.keys():
					local_bindings[bind] = closure.bindings[bind]	
				# evaluate each argument and bind it to the local level 
				for i in range(0, count):
					local_bindings[params[i]] = evaluate(args[i], bindings) 							
				expr = evaluate(closure.expr, local_bindings)
			if expr == None:
				expr = (ERROR, str(def_id) + " not defined in closure"+ str(closure))
		# empty closure, could not find
		else:
			if closure:
				if isinstance(closure, tuple) and closure[0] == ERROR:
					expr = closure
				else:
					expr = (ERROR, str(closure) + ' is not bound within this application: ')
			else:
				expr = (ERROR, 'Application is not defined: ')
	elif tag == ID:
		if value in bindings:
			expr = bindings[value] 			
		else:
			expr = (ERROR, tag + " not defined in this context")
	elif tag == FLOAT:
		expr = float(value)
	elif tag == INT:
		expr = int(value)
	elif tag == STRING:
		expr = str(value)
	elif tag == KEYWORD: #if keyword, get builtin definition
		expr = eval_builtin(root, bindings)
	elif tag == BUILTIN: # if builtin, evaluate
		expr = eval_builtin(value, bindings)
	#else error		
	return expr
 

# Run main after all defintions 
if __name__ == '__main__':
	main(sys.argv[1:])
